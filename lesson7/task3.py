#3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение,
# умножение и обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.
#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
#Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества
# ячеек этих двух клеток.
#Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.
#Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    number = int
    def __init__(self, number):
        self.number = number
        print(f"Создали новый объект из {self.number} клеток")

    def __add__(self, other):
        try:
            value = self.number + other.number
            assert isinstance(other, self.__class__)
            return Cell(int(value))
        except AssertionError:
            print("Добавляемый объект не является также клеткой")

    def __sub__(self, other):
        try:
            value = self.number - other.number
            assert value > 0
            return Cell(int(value))
        except AssertionError:
            print("Вычитаемый объект больше исходного объекта")

    def __mul__(self, other):
        value = self.number * other.number
        return Cell(int(value))

    def __truediv__(self, other):
        value = round(self.number // other.number)
        return Cell(int(value))

    def make_order(group_cells, n_row):
        crops = '*' * group_cells.number
        r_crops = [crops[x:x + n_row]
            for x in range(0, len(crops), n_row)]
        return '\n'.join(r_crops)
class Villain:
    number = int
    def __init__(self, number):
        self.number = number
        print(f"Создали вредный объект из {self.number} клеток")

Cell1 = Cell(20)
Cell2 = Cell(7)
group_cells = Cell(100)
Cell_pcevdo = Villain (3)
add = Cell1 + Cell2
add = Cell1 + Cell_pcevdo
subb = Cell1 - Cell2
subba = Cell2 - Cell1
mull = Cell1 * Cell2
td = Cell1 / Cell2

print (Cell.make_order(group_cells = group_cells, n_row=30))

